---
output: pdf_document
---
Solution to Driver Telematics Analysis
==============================
\n
<b>The goal of this competition is identify trips which are not from the driver of interest, based on their telematic features</b>

Here we created a simple R code to predict the true trips of each driver.

First, we created a folder called "driver" with subfolders "drivers" containing raw data. To run the scripts we first need to deploy all raw data set in "drivers" directory:



Then we want to set up global options:
```{r, fig.width = 4, fig.height=3, message = FALSE}

library("dplyr")
library("randomForest")
options(scipen=999)
setwd('/Users/kshen4/Desktop/driver') # change this path with your data folder
```

Then we read the raw data from "driver" folder, the first step is to generate features. We will give an example for the first 20 drivers here:
```{r, fig.width = 4, fig.height=3, message = FALSE}
Drivers <- as.numeric(list.files(path = "drivers/"))
Drivers = Drivers[1:20]
NB_DRIVERS <- 20
NB_TRIPS <- 200
```

We created a function called "Summary_Driver_Trips" to generate 29 features we need to use.
```{r, fig.width = 4, fig.height=3, message = FALSE}
Summary_Driver_Trips <- function(driver) {

  driver_files <- list.files(path = paste("./drivers/",driver,sep="")) # recover the names of the csv files
  	summary <- matrix(nrow=200, ncol=29) # initialize the matrix which will store the summary of the 200 trips
  	t=1 # trip counter (from 1 to 200)

	for (file in driver_files){ # for each csv file in each driver folder
    		#Recover trip data
		coord <- as.matrix(read.csv(paste("./drivers/",driver,"/", file, sep=""))) # x & y coordinates
		trip  <- as.numeric(strsplit(file,"[.]")[[1]][1])

    		#Create some variables for each record of the trip
		time = 1:nrow(coord)
		dist_to_origin = sqrt(coord[,1]^2 + coord[,2]^2)
		speed = 0 ; speed[2:nrow(coord)] = sqrt(diff(coord[,1],1)^2 + diff(coord[,2],1)^2)
		acc = 0 ; acc[2:nrow(coord)] = diff(speed,1)
		acc_flag = ifelse(acc>1.5, 1, 0) # flag for important accelerations
		dec_flag = ifelse(acc< -2, 1, 0) # flag for important decelerations

		#Aggregation at the trip level

		#Speed
		avg_speed=mean(speed); sd_speed=sd(speed); min_speed=min(speed); max_speed=max(speed)
		q1_speed=quantile(speed, probs = 0.25)
		q2_speed=quantile(speed, probs = 0.50)
		q3_speed=quantile(speed, probs = 0.75)
		#Acceleration
		avg_acc=mean(acc); sd_acc=sd(acc); min_acc=min(acc); max_acc=max(acc)
		q1_acc=quantile(acc, probs = 0.25)
		q2_acc=quantile(acc, probs = 0.50)
		q3_acc=quantile(acc, probs = 0.75)
		#Distance to origin
		avg_dist_to_orig=mean(dist_to_origin); sd_dist_to_orig=sd(dist_to_origin); max_dist_to_orig=max(dist_to_origin)
		q1_dist_to_orig=quantile(dist_to_origin, probs = 0.25)
		q2_dist_to_orig=quantile(dist_to_origin, probs = 0.50)
		q3_dist_to_orig=quantile(dist_to_origin, probs = 0.75)
		#Others
		trip_duration=max(time)
		crow_flight=sqrt(coord[nrow(coord), 1]^2 + coord[nrow(coord), 2]^2)
		acc_time=sum(acc_flag)
		dec_time=sum(dec_flag)
		trip_length = trip_duration * avg_speed
		crow_ratio = crow_flight / trip_length
		is_internal = 1 # for now we assume all the trips have been done by this driver

		summary[t,]= cbind(driver, trip,
                    		avg_speed, sd_speed, min_speed, max_speed, q1_speed, q2_speed, q3_speed, #speed features
		                avg_acc, sd_acc, min_acc, max_acc, q1_acc, q2_acc, q3_acc, #acc features
		                avg_dist_to_orig, sd_dist_to_orig, max_dist_to_orig, q1_dist_to_orig, q2_dist_to_orig, q3_dist_to_orig, #distance to origin features
		                acc_time, dec_time, trip_duration, crow_flight, trip_length, crow_ratio, is_internal) #others features
    				t=t+1 # increment the trip counter
	}
	return(summary)
}
```

The final step to generate features is to apply the "Summary_Driver_Trips" function to all the drivers and store the result in "DriversTripsSummary"
```{r, fig.width = 4, fig.height=3, message = FALSE}
GlobalTripsSummary = matrix(nrow=NB_DRIVERS * NB_TRIPS, ncol=29)
colnames(GlobalTripsSummary) =  c('driver', 'trip', 'avg_speed', 'sd_speed', 'min_speed', 'max_speed', 'q1_speed', 'q2_speed', 'q3_speed',
                         	'avg_acc', 'sd_acc', 'min_acc', 'max_acc', 'q1_acc', 'q2_acc', 'q3_acc',
                       		'avg_dist_to_orig', 'sd_dist_to_orig', 'max_dist_to_orig', 'q1_dist_to_orig', 'q2_dist_to_orig', 'q3_dist_to_orig',
                       		'acc_time', 'dec_time', 'trip_duration', 'crow_flight', 'trip_length', 'crow_ratio', 'is_internal')

d=1 # driver counter

for(driver in Drivers){
	driverTripsSummary= Summary_Driver_Trips(driver)
	GlobalTripsSummary[seq((d-1)*NB_TRIPS+1, d*NB_TRIPS),] = driverTripsSummary
	d=d+1
}
# Save the result in a csv file
write.csv(GlobalTripsSummary, 'GlobalTripsSummary.csv', row.names=FALSE)
```

Finally, We are calling the random forest model to predict the true trips for each driver
```{r, fig.width = 4, fig.height=3, message = FALSE}
NbDrivers = 20
NbTrips = 200

# global options
# disable scientific notation
options(scipen=999)
setwd('/Users/kshen4/Desktop/driver') # your data folder

GlobalTripsSummary = read.table('GlobalTripsSummary.csv', sep=',' , header = TRUE, stringsAsFactors=FALSE)
GlobalTripsSummary  = GlobalTripsSummary [order(GlobalTripsSummary$driver, GlobalTripsSummary$trip),]


#get the trips of a driver and add "NbExternalTrips" external trips to build the train set
CreateTrain = function(driver, NbExternalTrips){
  InternalTrips = GlobalTripsSummary[which(GlobalTripsSummary[,'driver']==driver), ]
	ExternalTrips = GlobalTripsSummary[sample(which(GlobalTripsSummary[,'driver']!=driver), size = NbExternalTrips), ]
	ExternalTrips[,'is_internal'] = 0
	Train = rbind(InternalTrips, ExternalTrips)
	return(Train)
}


# Recursive modelisation
ComputeProbability = function(Train){

	rf = randomForest(as.factor(is_internal) ~ avg_speed + sd_speed + max_speed + q1_speed + q2_speed + q3_speed
                      + avg_dist_to_orig  + sd_dist_to_orig + max_dist_to_orig + q1_dist_to_orig + q2_dist_to_orig + q3_dist_to_orig
                      + acc_time + dec_time + avg_acc + sd_acc + min_acc + max_acc + q1_acc + q2_acc + q3_acc + trip_duration
                      + crow_flight + trip_length + crow_ratio , ntree = 50, nodesize=5, importance = TRUE,  data=Train)
	predictions = predict(rf, Train[1:200, ], type = "prob")[,2]
	return(predictions)
}

driver_trip = paste(GlobalTripsSummary$driver, '_', GlobalTripsSummary$trip, sep = '')

CreateSubmission = function(NbExternalTrips, NbRecursion, NbTrain){
	prob_int = numeric(200)
	prob_final = numeric(200 * NbDrivers)
	## creation of a matrix where each vector is the probability of the train set
	prob_Trains=matrix(data=NA, nrow=NbTrips, ncol=NbTrain)

	i=1 # driver's count, which alternative

	for (driver in Drivers){
		print(i)
		for (j in 1:NbRecursion){
			for (train in 1:NbTrain){
				Train = CreateTrain(driver, NbExternalTrips)
				prob_Trains[,train]=ComputeProbability(Train)
			}
			prob_int=apply(X=prob_Trains, MARGIN=1, median)
			new_is_internal=ifelse(prob_int>=0.5,1,0)
			GlobalTripsSummary[seq((i-1)*200+1, i*200 ),"is_internal"]=new_is_internal
		}
		prob_final[seq((i-1)*200+1, i*200 )]=prob_int
		i=i+1
	}
	submission = cbind(driver_trip, prob_final)
	write.csv(submission, 'submission.csv', row.names=F, quote=F)
}

CreateSubmission(NbExternalTrips = 600, NbRecursion = 5, NbTrain= 50)


submission = read.table('submission.csv', sep=',' , header = TRUE, stringsAsFactors=FALSE)
submission = cbind(driver_trip, submission$prob_final)

write.csv(submission, 'submission.csv', row.names=F, quote=F)
```
